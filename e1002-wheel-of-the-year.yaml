################################################################################
# reTerminal E1002 – Wheel of the Year  ·  Wicca Calendar Display
# Hardware: Seeed Studio reTerminal E1002
#   - 7.3" E Ink Spectra 6 color ePaper  (800×480, 6 colors)
#   - ESP32-S3 with 8MB PSRAM
#   - Internal SHT40 temp/humidity sensor
#   - SPI: CLK=GPIO7, MOSI=GPIO9
#   - I2C: SDA=GPIO19, SCL=GPIO20
#
# IMPORTANT: Framework MUST be "arduino" (not esp-idf) for PSRAM to work.
#
# Prerequisites:
#   Install the Wheel of the Year HA integration via HACS:
#     https://github.com/MorningstarOwl/ha-wheel-of-the-year
#   This provides all 24 sensor entities used below.
#
# Display layout (800 × 480, 6-color Spectra 6):
#
#  ┌─────────────────────────────────────────────────────────────────────────┐
#  │  HEADER  (y 0–52)  Black bg / White+Yellow text                       │
#  │  "WHEEL OF THE YEAR"    date    battery%                              │
#  ├──────────────────────────────┬──────────────────────────────────────────┤
#  │  MOON PHASE  (x 0–310)      │  NEXT SABBAT  (x 320–520)  │ SEASON+   │
#  │  Moon disc (centered top)    │  Name + countdown          │ SUN SIGN  │
#  │  Phase name (below disc)     │  Alt name + date           │ (x 530–   │
#  │  Illumination %              │  Description (3 lines)     │  800)     │
#  │  Magick (2 lines, wrapped)   │                            │           │
#  │  (y 56–262)                  │  (y 56–262)                │           │
#  ├──────────────────────────────┴────────────────────────────┴───────────┤
#  │  PLANETARY POSITIONS  (y 256–312)                                     │
#  │  Sun · Moon · Mercury · Venus · Mars · Jupiter · Saturn               │
#  ├───────────────────────────────────────────────────────────────────────┤
#  │  SABBAT COUNTDOWNS  (y 314–478)  — 8 sabbats, 2 rows × 4 columns    │
#  │  Row 1:  Yule  │  Imbolc  │  Ostara  │  Beltane                      │
#  │  Row 2:  Litha │ Lughnasadh │  Mabon  │  Samhain                     │
#  └───────────────────────────────────────────────────────────────────────┘
#
# Available ePaper colors: BLACK  WHITE  RED  GREEN  YELLOW  BLUE
# (RED on Spectra 6 renders as a warm orange-red)
################################################################################

esphome:
  name: reterminal-wicca
  friendly_name: Wheel of the Year
  on_boot:
    priority: 600
    then:
      - output.turn_on: bsp_battery_enable
      - delay: 200ms
      - component.update: battery_voltage
      - component.update: battery_level

################################################################################
# ESP32-S3 — framework MUST be Arduino for 8MB PSRAM support
################################################################################
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino

psram:
  mode: octal
  speed: 80MHz

################################################################################
# Core services
################################################################################
logger:

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Reterminal-Wicca"
    password: !secret ap_password

captive_portal:

################################################################################
# Time
################################################################################
time:
  - platform: homeassistant
    id: ha_time

################################################################################
# GPIO — battery measurement circuit enable
################################################################################
output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

################################################################################
# Green button — manual display refresh
# GPIO3 is the top green button (active-low, internal pull-up)
################################################################################
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO3
      mode: INPUT_PULLUP
      inverted: true
    name: "Refresh Button"
    filters:
      - delayed_on: 50ms
    on_press:
      then:
        - component.update: epaper_display

################################################################################
# I²C bus — internal SHT40
################################################################################
i2c:
  sda: GPIO19
  scl: GPIO20
  scan: false

################################################################################
# SPI bus — ePaper display
################################################################################
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9

################################################################################
# Fonts
################################################################################
font:
  - file: "gfonts://Cinzel@700"
    id: font_title         # Main header title
    size: 30

  - file: "gfonts://Cinzel@600"
    id: font_heading       # Section headings
    size: 26

  - file: "gfonts://Inter@700"
    id: font_large         # Sabbat name, season name
    size: 32

  - file: "gfonts://Inter@700"
    id: font_medium        # Section labels, countdown days
    size: 22

  - file: "gfonts://Inter@600"
    id: font_body          # Body text
    size: 18

  - file: "gfonts://Inter@600"
    id: font_small         # Captions, planet positions
    # ~8.5px per char → 35 chars fit in 298px (moon column, x=12–308)
    size: 15

  - file: "gfonts://Inter@700"
    id: font_tiny          # Smallest labels
    # ~7px per char → 26 chars fit in 186px (sabbat desc column, x=320–506)
    size: 12

################################################################################
# Sensors
################################################################################
sensor:
  - platform: homeassistant
    id: sabbat_yule
    entity_id: sensor.wheel_of_the_year_yule

  - platform: homeassistant
    id: sabbat_imbolc
    entity_id: sensor.wheel_of_the_year_imbolc

  - platform: homeassistant
    id: sabbat_ostara
    entity_id: sensor.wheel_of_the_year_ostara

  - platform: homeassistant
    id: sabbat_beltane
    entity_id: sensor.wheel_of_the_year_beltane

  - platform: homeassistant
    id: sabbat_litha
    entity_id: sensor.wheel_of_the_year_litha

  - platform: homeassistant
    id: sabbat_lughnasadh
    entity_id: sensor.wheel_of_the_year_lughnasadh

  - platform: homeassistant
    id: sabbat_mabon
    entity_id: sensor.wheel_of_the_year_mabon

  - platform: homeassistant
    id: sabbat_samhain
    entity_id: sensor.wheel_of_the_year_samhain

  - platform: homeassistant
    id: moon_illumination
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: illumination

  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 1800s
    attenuation: 12db
    filters:
      - multiply: 2.0

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    update_interval: never
    lambda: |-
      float v = id(battery_voltage).state;
      if (v >= 4.2) return 100.0;
      if (v <= 3.2) return 0.0;
      return (v - 3.2) / (4.2 - 3.2) * 100.0;

  - platform: sht4x
    address: 0x44
    update_interval: 3600s
    temperature:
      name: "Indoor Temperature"
      id: indoor_temp
      internal: true
    humidity:
      name: "Indoor Humidity"
      id: indoor_humidity
      internal: true
      on_value:
        then:
          - component.update: epaper_display

################################################################################
# Text sensors
################################################################################
text_sensor:
  - platform: homeassistant
    id: moon_phase
    entity_id: sensor.wheel_of_the_year_moon_phase

  - platform: homeassistant
    id: moon_magick
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: magick

  - platform: homeassistant
    id: moon_emoji
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: emoji

  - platform: homeassistant
    id: sun_sign
    entity_id: sensor.wheel_of_the_year_sun_sign

  - platform: homeassistant
    id: sun_sign_symbol
    entity_id: sensor.wheel_of_the_year_sun_sign
    attribute: symbol

  - platform: homeassistant
    id: sun_sign_element
    entity_id: sensor.wheel_of_the_year_sun_sign
    attribute: element

  - platform: homeassistant
    id: current_season
    entity_id: sensor.wheel_of_the_year_current_season

  - platform: homeassistant
    id: season_emoji
    entity_id: sensor.wheel_of_the_year_current_season
    attribute: emoji

  - platform: homeassistant
    id: season_description
    entity_id: sensor.wheel_of_the_year_current_season
    attribute: short_description

  - platform: homeassistant
    id: next_sabbat
    entity_id: sensor.wheel_of_the_year_next_sabbat

  - platform: homeassistant
    id: next_sabbat_alt
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: alt_name

  - platform: homeassistant
    id: next_sabbat_date
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: date

  - platform: homeassistant
    id: next_sabbat_description
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: description

  - platform: homeassistant
    id: planet_sun
    entity_id: sensor.wheel_of_the_year_sun_position

  - platform: homeassistant
    id: planet_moon
    entity_id: sensor.wheel_of_the_year_moon_position

  - platform: homeassistant
    id: planet_mercury
    entity_id: sensor.wheel_of_the_year_mercury_position

  - platform: homeassistant
    id: planet_venus
    entity_id: sensor.wheel_of_the_year_venus_position

  - platform: homeassistant
    id: planet_mars
    entity_id: sensor.wheel_of_the_year_mars_position

  - platform: homeassistant
    id: planet_jupiter
    entity_id: sensor.wheel_of_the_year_jupiter_position

  - platform: homeassistant
    id: planet_saturn
    entity_id: sensor.wheel_of_the_year_saturn_position

  - platform: homeassistant
    id: solar_cycle
    entity_id: sensor.wheel_of_the_year_solar_cycle

################################################################################
# ePaper Display
################################################################################
display:
  - platform: epaper_spi
    id: epaper_display
    model: Seeed-reTerminal-E1002
    update_interval: never
    lambda: |-

      // ── Color palette (Spectra 6) ────────────────────────────────────────
      const auto BLACK  = Color(0,   0,   0,   0);
      const auto WHITE  = Color(255, 255, 255, 0);
      const auto RED    = Color(255, 0,   0,   0);
      const auto GREEN  = Color(0,   200, 0,   0);
      const auto YELLOW = Color(255, 220, 0,   0);
      const auto BLUE   = Color(0,   0,   220, 0);

      const int W = 800;
      const int H = 480;

      // ── Helper: word-wrap a string into fixed-width lines ────────────────
      // Splits `s` into segments of at most `max_chars`, breaking on spaces.
      // Returns up to `max_lines` segments; last segment gets "..." if truncated.
      auto wrap_text = [](const std::string &s, int max_chars, int max_lines)
          -> std::vector<std::string> {
        std::vector<std::string> lines;
        std::string remain = s;
        for (int i = 0; i < max_lines && !remain.empty(); i++) {
          if ((int)remain.length() <= max_chars) {
            lines.push_back(remain);
            remain.clear();
          } else {
            // Find last space at or before max_chars
            size_t cut = remain.rfind(' ', max_chars);
            if (cut == std::string::npos) cut = max_chars; // hard break
            std::string seg = remain.substr(0, cut);
            remain = remain.substr(cut + (remain[cut] == ' ' ? 1 : 0));
            // If this is the last allowed line and text still remains, add ellipsis
            if (i == max_lines - 1 && !remain.empty()) {
              if ((int)seg.length() > max_chars - 3)
                seg = seg.substr(0, max_chars - 3);
              seg += "...";
            }
            lines.push_back(seg);
          }
        }
        return lines;
      };

      // Fill entire display background
      it.filled_rectangle(0, 0, W, H, BLACK);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 1 — HEADER BAR  (y: 0–52)
      // ════════════════════════════════════════════════════════════════════════
      it.filled_rectangle(0, 0, W, 52, BLACK);
      it.print(16, 10, id(font_title), YELLOW, "WHEEL OF THE YEAR");

      auto now = id(ha_time).now();
      if (now.is_valid()) {
        char datebuf[32];
        now.strftime(datebuf, sizeof(datebuf), "%a  %b %d, %Y");
        it.print(W - 16, 12, id(font_medium), WHITE, TextAlign::TOP_RIGHT, datebuf);
      }

      float batt = id(battery_level).state;
      if (!isnan(batt)) {
        it.printf(W - 16, 35, id(font_tiny), WHITE,
                  TextAlign::TOP_RIGHT, "Battery: %.0f%%", batt);
      }

      if (id(current_season).has_state()) {
        std::string season_str = id(current_season).state;
        Color season_col = WHITE;
        if (season_str == "Spring")      season_col = GREEN;
        else if (season_str == "Summer") season_col = YELLOW;
        else if (season_str == "Autumn") season_col = RED;
        else if (season_str == "Winter") season_col = BLUE;
        it.printf(400, 35, id(font_tiny), season_col,
                  TextAlign::TOP_CENTER, "%s", season_str.c_str());
      }

      it.filled_rectangle(0, 52, W, 2, YELLOW);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2a — MOON PHASE  (x: 0–310, y: 54–262)
      //
      // Column usable width:  x=12 → x=308 = 296px
      // font_small  (~8.5px/char) → 34 chars max per line
      // font_medium (~13px/char)  → 22 chars max (covers "Waxing Gibbous" = 14)
      //
      // Vertical layout:
      //   y= 58  "LUNAR PHASE" heading (font_medium)
      //   y= 80  rule
      //   y= 84  Moon disc, center (155, 122), radius 36
      //          disc occupies y=86–158
      //   y= 163 Phase name (font_medium, 22px)
      //   y= 188 Illumination % (font_body, 18px)
      //   y= 210 "Magick:" label (font_small, 15px)
      //   y= 226 Magick line 1  (font_small, 15px)
      //   y= 243 Magick line 2  (font_small, 15px) — baseline ~y=255, fits
      // ════════════════════════════════════════════════════════════════════════
      it.print(12, 58, id(font_medium), BLUE, "LUNAR PHASE");
      it.filled_rectangle(12, 80, 285, 1, BLUE);

      const int MX     = 155;
      const int MY     = 122;
      const int MOON_R = 36;

      float illum = 0.0f;
      if (!isnan(id(moon_illumination).state))
        illum = id(moon_illumination).state;

      bool is_waning = false;
      if (id(moon_phase).has_state()) {
        const std::string &ph = id(moon_phase).state;
        is_waning = (ph.find("Waning") != std::string::npos ||
                     ph.find("Third")  != std::string::npos);
      }

      // Dark base disc
      it.filled_circle(MX, MY, MOON_R, BLACK);

      // Lit portion via vertical scan lines
      int lit_width = (int)(MOON_R * 2.0f * illum / 100.0f);
      if (lit_width > 0) {
        if (is_waning) {
          for (int col = 0; col < lit_width && col < MOON_R * 2; col++) {
            int x  = MX - MOON_R + 1 + col;
            int dx = x - MX;
            int h  = (int)sqrtf((float)(MOON_R * MOON_R - dx * dx));
            if (h > 0) it.line(x, MY - h + 1, x, MY + h - 1, WHITE);
          }
        } else {
          for (int col = 0; col < lit_width && col < MOON_R * 2; col++) {
            int x  = MX + MOON_R - 1 - col;
            int dx = x - MX;
            int h  = (int)sqrtf((float)(MOON_R * MOON_R - dx * dx));
            if (h > 0) it.line(x, MY - h + 1, x, MY + h - 1, WHITE);
          }
        }
      }
      // Redraw outline over scan lines
      it.circle(MX, MY, MOON_R, WHITE);

      // Phase name
      if (id(moon_phase).has_state())
        it.print(12, 163, id(font_medium), WHITE, id(moon_phase).state.c_str());
      else
        it.print(12, 163, id(font_medium), WHITE, "---");

      // Illumination
      if (!isnan(illum))
        it.printf(12, 188, id(font_body), WHITE, "%.0f%% Illuminated", illum);

      // Magick — wrap to 2 lines of 34 chars each (font_small ~8.5px → 289px max)
      it.print(12, 210, id(font_small), BLUE, "Magick:");
      if (id(moon_magick).has_state()) {
        auto mlines = wrap_text(id(moon_magick).state, 34, 2);
        int my_y = 226;
        for (auto &ml : mlines) {
          it.print(12, my_y, id(font_small), WHITE, ml.c_str());
          my_y += 17;
        }
      }

      it.filled_rectangle(310, 54, 2, 210, WHITE);  // vertical divider

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2b — NEXT SABBAT  (x: 320–520, y: 54–262)
      //
      // Column usable width:  x=320 → x=518 = 198px
      // font_tiny (~7px/char) → 28 chars max per line
      // font_large (32px) — "Lughnasadh" = 10 chars × ~19px ≈ 190px, just fits
      //
      // Vertical layout:
      //   y= 58  "NEXT SABBAT" heading (font_medium)
      //   y= 80  rule
      //   y= 88  Sabbat name (font_large, 32px)
      //   y= 124 Alt name (font_body, 18px)
      //   y= 146 Date string (font_small, 15px)
      //   y= 164 Days countdown (font_medium, 22px)
      //   y= 190 Description line 1 (font_tiny, 12px)
      //   y= 204 Description line 2 (font_tiny, 12px)
      //   y= 218 Description line 3 (font_tiny, 12px)
      //   y= 232 Description line 4 (font_tiny, 12px)  ← extra line vs before
      // ════════════════════════════════════════════════════════════════════════
      it.print(320, 58, id(font_medium), RED, "NEXT SABBAT");
      it.filled_rectangle(320, 80, 195, 1, RED);

      if (id(next_sabbat).has_state())
        it.print(320, 88, id(font_large), YELLOW, id(next_sabbat).state.c_str());

      if (id(next_sabbat_alt).has_state())
        it.print(320, 124, id(font_body), WHITE, id(next_sabbat_alt).state.c_str());

      if (id(next_sabbat_date).has_state())
        it.print(320, 146, id(font_small), WHITE, id(next_sabbat_date).state.c_str());

      // Days countdown
      float days_left = NAN;
      if (id(next_sabbat).has_state()) {
        const std::string &ns = id(next_sabbat).state;
        if      (ns == "Yule")        days_left = id(sabbat_yule).state;
        else if (ns == "Imbolc")      days_left = id(sabbat_imbolc).state;
        else if (ns == "Ostara")      days_left = id(sabbat_ostara).state;
        else if (ns == "Beltane")     days_left = id(sabbat_beltane).state;
        else if (ns == "Litha")       days_left = id(sabbat_litha).state;
        else if (ns == "Lughnasadh")  days_left = id(sabbat_lughnasadh).state;
        else if (ns == "Mabon")       days_left = id(sabbat_mabon).state;
        else if (ns == "Samhain")     days_left = id(sabbat_samhain).state;
      }
      if (!isnan(days_left)) {
        if (days_left < 0.5)
          it.print(320, 164, id(font_medium), YELLOW, "TODAY!");
        else
          it.printf(320, 164, id(font_medium), RED, "%.0f days", days_left);
      }

      // Description — wrap to 4 lines of 28 chars (font_tiny ~7px → 196px max)
      if (id(next_sabbat_description).has_state()) {
        auto dlines = wrap_text(id(next_sabbat_description).state, 28, 4);
        int dy = 190;
        for (auto &dl : dlines) {
          it.print(320, dy, id(font_tiny), WHITE, dl.c_str());
          dy += 14;
        }
      }

      it.filled_rectangle(525, 54, 2, 210, WHITE);  // vertical divider

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2c — SUN SIGN + SEASON  (x: 535–790, y: 54–262)
      //
      // Column usable width: x=535 → x=788 = 253px
      // font_tiny (~7px/char) → 36 chars max per line
      // ════════════════════════════════════════════════════════════════════════
      it.print(535, 58, id(font_medium), YELLOW, "SUN SIGN");
      it.filled_rectangle(535, 80, 255, 1, YELLOW);

      if (id(sun_sign).has_state())
        it.print(535, 88, id(font_large), WHITE, id(sun_sign).state.c_str());

      if (id(sun_sign_element).has_state())
        it.print(535, 124, id(font_body), GREEN, id(sun_sign_element).state.c_str());

      it.filled_rectangle(535, 150, 255, 1, WHITE);
      it.print(535, 156, id(font_medium), GREEN, "SEASON");

      if (id(current_season).has_state()) {
        Color s_col = WHITE;
        const std::string &sn = id(current_season).state;
        if (sn == "Spring")      s_col = GREEN;
        else if (sn == "Summer") s_col = YELLOW;
        else if (sn == "Autumn") s_col = RED;
        else if (sn == "Winter") s_col = BLUE;
        it.print(535, 178, id(font_large), s_col, sn.c_str());
      }

      if (id(season_description).has_state()) {
        auto slines = wrap_text(id(season_description).state, 36, 2);
        int sy = 216;
        for (auto &sl : slines) {
          it.print(535, sy, id(font_tiny), WHITE, sl.c_str());
          sy += 14;
        }
      }

      // Horizontal rule separating top panels from planetary row
      it.filled_rectangle(0, 264, W, 2, WHITE);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 3 — PLANETARY POSITIONS  (y: 266–318)
      // No title bar — full 52px given to planet name + sign text.
      //   P_Y      = 268  planet name label  (font_tiny  12px → baseline ~280)
      //   P_Y + 16 = 284  sign + degree text (font_small 15px → baseline ~299)
      //   Column dividers span y=266–318 (52px)
      // ════════════════════════════════════════════════════════════════════════
      const int P_Y     = 268;
      const int P_COLS  = 7;
      const int P_COL_W = W / P_COLS;  // 114px

      it.print(P_COL_W * 0 + 6, P_Y, id(font_tiny), YELLOW, "Sun");
      if (id(planet_sun).has_state())
        it.print(P_COL_W * 0 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_sun).state.c_str());

      it.print(P_COL_W * 1 + 6, P_Y, id(font_tiny), BLUE, "Moon");
      if (id(planet_moon).has_state())
        it.print(P_COL_W * 1 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_moon).state.c_str());

      it.print(P_COL_W * 2 + 6, P_Y, id(font_tiny), WHITE, "Mercury");
      if (id(planet_mercury).has_state())
        it.print(P_COL_W * 2 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_mercury).state.c_str());

      it.print(P_COL_W * 3 + 6, P_Y, id(font_tiny), GREEN, "Venus");
      if (id(planet_venus).has_state())
        it.print(P_COL_W * 3 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_venus).state.c_str());

      it.print(P_COL_W * 4 + 6, P_Y, id(font_tiny), RED, "Mars");
      if (id(planet_mars).has_state())
        it.print(P_COL_W * 4 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_mars).state.c_str());

      it.print(P_COL_W * 5 + 6, P_Y, id(font_tiny), YELLOW, "Jupiter");
      if (id(planet_jupiter).has_state())
        it.print(P_COL_W * 5 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_jupiter).state.c_str());

      it.print(P_COL_W * 6 + 6, P_Y, id(font_tiny), WHITE, "Saturn");
      if (id(planet_saturn).has_state())
        it.print(P_COL_W * 6 + 6, P_Y + 16, id(font_small), WHITE,
                 id(planet_saturn).state.c_str());

      for (int i = 1; i < P_COLS; i++)
        it.filled_rectangle(P_COL_W * i, 266, 1, 52, WHITE);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 4 — SABBAT COUNTDOWNS  (y: 318–478)
      //
      // Geometry budget:
      //   SB_Y0   = 318   (grid starts immediately, no title bar)
      //   CELL_H  =  80px (2 rows × 80 = 160px)
      //   Grid bottom = 318 + 160 = 478 ≤ 480  ✓
      //
      // Cell text positions (relative to cell top y0):
      //   y0 + 4   Sabbat name    (font_medium 22px → baseline y0+26)
      //   y0 + 30  Alt name       (font_tiny   12px → baseline y0+42)
      //   y0 + 50  Days countdown (font_medium 22px → baseline y0+72) ✓
      // ════════════════════════════════════════════════════════════════════════
      const int SB_Y0  = 318;
      const int SB_TOP = SB_Y0;         // grid starts immediately, no title bar
      const int CELL_W = 200;           // 800 / 4
      const int CELL_H = 80;            // 2 rows × 80 = 160px; 318+160=478 ≤ 480 ✓

      struct SabbatInfo {
        const char *name;
        const char *alt;
        int type;       // 0=solar, 1=cross-quarter
        float days;
      };

      SabbatInfo sabbats[8] = {
        {"Yule",       "Winter Solstice",  0, id(sabbat_yule).state},
        {"Imbolc",     "Brigid's Day",     1, id(sabbat_imbolc).state},
        {"Ostara",     "Spring Equinox",   0, id(sabbat_ostara).state},
        {"Beltane",    "May Day",          1, id(sabbat_beltane).state},
        {"Litha",      "Summer Solstice",  0, id(sabbat_litha).state},
        {"Lughnasadh", "Lammas",           1, id(sabbat_lughnasadh).state},
        {"Mabon",      "Autumn Equinox",   0, id(sabbat_mabon).state},
        {"Samhain",    "Hallows' Eve",     1, id(sabbat_samhain).state},
      };

      // Find next sabbat
      int next_idx = -1;
      float min_days = 999.0f;
      for (int i = 0; i < 8; i++) {
        if (!isnan(sabbats[i].days) && sabbats[i].days >= 0.0f &&
            sabbats[i].days < min_days) {
          min_days = sabbats[i].days;
          next_idx = i;
        }
      }

      for (int i = 0; i < 8; i++) {
        int col = i % 4;
        int row = i / 4;
        int x0  = col * CELL_W;
        int y0  = SB_TOP + row * CELL_H;

        if (i == next_idx)
          it.filled_rectangle(x0 + 1, y0 + 1, CELL_W - 2, CELL_H - 2, YELLOW);

        it.rectangle(x0, y0, CELL_W, CELL_H, WHITE);

        // Sabbat name
        Color name_col = (sabbats[i].type == 0) ? YELLOW : RED;
        if (i == next_idx) name_col = BLACK;
        it.print(x0 + 8, y0 + 4, id(font_medium), name_col, sabbats[i].name);

        // Alt name (BLACK on yellow highlight, WHITE on dark background)
        it.print(x0 + 8, y0 + 30, id(font_tiny),
                 (i == next_idx) ? BLACK : WHITE, sabbats[i].alt);

        // Days countdown
        if (!isnan(sabbats[i].days)) {
          if (sabbats[i].days < 0.5f) {
            it.print(x0 + 8, y0 + 50, id(font_medium),
                     (i == next_idx) ? RED : GREEN, "TODAY!");
          } else {
            Color days_col = (i == next_idx) ? RED : BLUE;
            it.printf(x0 + 8, y0 + 50, id(font_medium), days_col,
                      "%.0f days", sabbats[i].days);
          }
        } else {
          it.print(x0 + 8, y0 + 50, id(font_medium),
                   (i == next_idx) ? BLACK : WHITE, "---");
        }
      }

      // Bottom border
      it.filled_rectangle(0, SB_TOP + 2 * CELL_H, W, 2, WHITE);