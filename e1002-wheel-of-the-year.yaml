################################################################################
# reTerminal E1002 – Wheel of the Year  ·  Wicca Calendar Display
# Hardware: Seeed Studio reTerminal E1002
#   - 7.3" E Ink Spectra 6 color ePaper  (800×480, 6 colors)
#   - ESP32-S3 with 8MB PSRAM
#   - Internal SHT40 temp/humidity sensor
#   - SPI: CLK=GPIO7, MOSI=GPIO9
#   - I2C: SDA=GPIO19, SCL=GPIO20
#
# IMPORTANT: Framework MUST be "arduino" (not esp-idf) for PSRAM to work.
#
# Prerequisites:
#   Install the Wheel of the Year HA integration via HACS:
#     https://github.com/MorningstarOwl/ha-wheel-of-the-year
#   This provides all 24 sensor entities used below.
#
# Display layout (800 × 480, 6-color Spectra 6):
#
#  ┌─────────────────────────────────────────────────────────────────────────┐
#  │  HEADER  (y 0–52)  Black bg / White+Yellow text                       │
#  │  "WHEEL OF THE YEAR"    date    battery%                              │
#  ├──────────────────────────────┬──────────────────────────────────────────┤
#  │  MOON PHASE  (x 0–310)      │  NEXT SABBAT  (x 320–520)  │ SEASON+   │
#  │  Large phase name            │  Name + countdown          │ SUN SIGN  │
#  │  Illumination %              │  Alt name                  │ (x 530–   │
#  │  Drawn moon circle           │  Traditions                │  800)     │
#  │  Magickal associations       │                            │           │
#  │  (y 56–265)                  │  (y 56–265)                │           │
#  ├──────────────────────────────┴────────────────────────────┴───────────┤
#  │  PLANETARY POSITIONS  (y 268–310)                                     │
#  │  Sun · Moon · Mercury · Venus · Mars · Jupiter · Saturn               │
#  ├───────────────────────────────────────────────────────────────────────┤
#  │  SABBAT COUNTDOWNS  (y 314–478)  — 8 sabbats, 2 rows × 4 columns    │
#  │  Row 1:  Yule  │  Imbolc  │  Ostara  │  Beltane                      │
#  │  Row 2:  Litha │ Lughnasadh │  Mabon  │  Samhain                     │
#  └───────────────────────────────────────────────────────────────────────┘
#
# Available ePaper colors: BLACK  WHITE  RED  GREEN  YELLOW  BLUE
# (RED on Spectra 6 renders as a warm orange-red)
################################################################################

esphome:
  name: reterminal-wicca
  friendly_name: Wheel of the Year
  on_boot:
    priority: 600
    then:
      - output.turn_on: bsp_battery_enable
      - delay: 200ms
      - component.update: battery_voltage
      - component.update: battery_level

################################################################################
# ESP32-S3 — framework MUST be Arduino for 8MB PSRAM support
################################################################################
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino

psram:
  mode: octal
  speed: 80MHz

################################################################################
# Core services
################################################################################
logger:

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Reterminal-Wicca"
    password: !secret ap_password

captive_portal:

################################################################################
# Time
################################################################################
time:
  - platform: homeassistant
    id: ha_time

################################################################################
# GPIO — battery measurement circuit enable
################################################################################
output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

################################################################################
# I²C bus — internal SHT40
################################################################################
i2c:
  sda: GPIO19
  scl: GPIO20
  scan: false

################################################################################
# SPI bus — ePaper display
################################################################################
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9

################################################################################
# Fonts
# Cinzel for headers (thematic serif), Inter for body text.
# ePaper benefits from bold weights at all sizes.
################################################################################
font:
  - file: "gfonts://Cinzel@700"
    id: font_title         # Main header title
    size: 30

  - file: "gfonts://Cinzel@600"
    id: font_heading       # Section headings, large feature text
    size: 26

  - file: "gfonts://Inter@700"
    id: font_large         # Large values (moon phase name, sabbat name)
    size: 32

  - file: "gfonts://Inter@700"
    id: font_medium        # Section labels, medium values
    size: 22

  - file: "gfonts://Inter@600"
    id: font_body          # Body text, descriptions
    size: 18

  - file: "gfonts://Inter@600"
    id: font_small         # Captions, planet positions, countdown values
    size: 15

  - file: "gfonts://Inter@700"
    id: font_tiny          # Smallest labels
    size: 12

################################################################################
# Sensors — numeric values from Wheel of the Year integration
################################################################################
sensor:
  # ── 8 Sabbat countdown sensors (state = days until) ─────────────────────
  - platform: homeassistant
    id: sabbat_yule
    entity_id: sensor.wheel_of_the_year_yule

  - platform: homeassistant
    id: sabbat_imbolc
    entity_id: sensor.wheel_of_the_year_imbolc

  - platform: homeassistant
    id: sabbat_ostara
    entity_id: sensor.wheel_of_the_year_ostara

  - platform: homeassistant
    id: sabbat_beltane
    entity_id: sensor.wheel_of_the_year_beltane

  - platform: homeassistant
    id: sabbat_litha
    entity_id: sensor.wheel_of_the_year_litha

  - platform: homeassistant
    id: sabbat_lughnasadh
    entity_id: sensor.wheel_of_the_year_lughnasadh

  - platform: homeassistant
    id: sabbat_mabon
    entity_id: sensor.wheel_of_the_year_mabon

  - platform: homeassistant
    id: sabbat_samhain
    entity_id: sensor.wheel_of_the_year_samhain

  # ── Moon illumination (attribute from moon_phase sensor) ─────────────────
  - platform: homeassistant
    id: moon_illumination
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: illumination

  # ── Battery ──────────────────────────────────────────────────────────────
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 1800s
    attenuation: 12db
    filters:
      - multiply: 2.0

  - platform: template
    name: "Battery Level"
    id: battery_level
    unit_of_measurement: "%"
    update_interval: never
    lambda: |-
      float v = id(battery_voltage).state;
      if (v >= 4.2) return 100.0;
      if (v <= 3.2) return 0.0;
      return (v - 3.2) / (4.2 - 3.2) * 100.0;

  # ── Internal SHT40 — used as display refresh trigger ────────────────────
  - platform: sht4x
    address: 0x44
    update_interval: 3600s         # 1-hour refresh cycle
    temperature:
      name: "Indoor Temperature"
      id: indoor_temp
      internal: true
    humidity:
      name: "Indoor Humidity"
      id: indoor_humidity
      internal: true
      on_value:
        then:
          - component.update: epaper_display

################################################################################
# Text sensors — string values from Wheel of the Year integration
################################################################################
text_sensor:
  # ── Moon Phase ───────────────────────────────────────────────────────────
  - platform: homeassistant
    id: moon_phase
    entity_id: sensor.wheel_of_the_year_moon_phase
    # State: "Full Moon", "Waxing Crescent", etc.

  - platform: homeassistant
    id: moon_magick
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: magick

  - platform: homeassistant
    id: moon_emoji
    entity_id: sensor.wheel_of_the_year_moon_phase
    attribute: emoji

  # ── Sun Sign ─────────────────────────────────────────────────────────────
  - platform: homeassistant
    id: sun_sign
    entity_id: sensor.wheel_of_the_year_sun_sign
    # State: "Pisces", "Aries", etc.

  - platform: homeassistant
    id: sun_sign_symbol
    entity_id: sensor.wheel_of_the_year_sun_sign
    attribute: symbol

  - platform: homeassistant
    id: sun_sign_element
    entity_id: sensor.wheel_of_the_year_sun_sign
    attribute: element

  # ── Current Season ───────────────────────────────────────────────────────
  - platform: homeassistant
    id: current_season
    entity_id: sensor.wheel_of_the_year_current_season
    # State: "Winter", "Spring", etc.

  - platform: homeassistant
    id: season_emoji
    entity_id: sensor.wheel_of_the_year_current_season
    attribute: emoji

  - platform: homeassistant
    id: season_description
    entity_id: sensor.wheel_of_the_year_current_season
    attribute: short_description

  # ── Next Sabbat ──────────────────────────────────────────────────────────
  - platform: homeassistant
    id: next_sabbat
    entity_id: sensor.wheel_of_the_year_next_sabbat
    # State: "Ostara", "Beltane", etc.

  - platform: homeassistant
    id: next_sabbat_alt
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: alt_name

  - platform: homeassistant
    id: next_sabbat_date
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: date

  - platform: homeassistant
    id: next_sabbat_description
    entity_id: sensor.wheel_of_the_year_next_sabbat
    attribute: description

  # ── Planetary Positions (state = "Sign Degree°") ────────────────────────
  - platform: homeassistant
    id: planet_sun
    entity_id: sensor.wheel_of_the_year_sun_position

  - platform: homeassistant
    id: planet_moon
    entity_id: sensor.wheel_of_the_year_moon_position

  - platform: homeassistant
    id: planet_mercury
    entity_id: sensor.wheel_of_the_year_mercury_position

  - platform: homeassistant
    id: planet_venus
    entity_id: sensor.wheel_of_the_year_venus_position

  - platform: homeassistant
    id: planet_mars
    entity_id: sensor.wheel_of_the_year_mars_position

  - platform: homeassistant
    id: planet_jupiter
    entity_id: sensor.wheel_of_the_year_jupiter_position

  - platform: homeassistant
    id: planet_saturn
    entity_id: sensor.wheel_of_the_year_saturn_position

  # ── Solar Cycle ──────────────────────────────────────────────────────────
  - platform: homeassistant
    id: solar_cycle
    entity_id: sensor.wheel_of_the_year_solar_cycle

################################################################################
# ePaper Display — Wheel of the Year  ·  Wicca Calendar
# 7.3" E Ink Spectra 6  |  800×480  |  6 colors
#
# Color usage:
#   BLACK  — body text, rules, outlines
#   WHITE  — header text, highlight text on dark backgrounds
#   RED    — fire sabbats (Imbolc, Beltane, Lughnasadh, Samhain), highs
#   GREEN  — earth/nature elements, season label
#   YELLOW — sun/solar, sabbat names, next-sabbat highlight
#   BLUE   — moon/water, header bar, planetary labels
#
# Refresh triggered by SHT40 on_value (every 300s). Color ePaper ~30s refresh.
################################################################################
display:
  - platform: epaper_spi
    id: epaper_display
    model: Seeed-reTerminal-E1002
    update_interval: never
    lambda: |-

      // ── Color palette (Spectra 6) ────────────────────────────────────────
      const auto BLACK  = Color(0,   0,   0,   0);
      const auto WHITE  = Color(255, 255, 255, 0);
      const auto RED    = Color(255, 0,   0,   0);
      const auto GREEN  = Color(0,   200, 0,   0);
      const auto YELLOW = Color(255, 220, 0,   0);
      const auto BLUE   = Color(0,   0,   220, 0);

      const int W = 800;
      const int H = 480;

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 1 — HEADER BAR  (y: 0–52)
      // Dark bar with title, date, and battery
      // ════════════════════════════════════════════════════════════════════════
      it.filled_rectangle(0, 0, W, 52, BLACK);

      it.print(16, 10, id(font_title), YELLOW, "WHEEL OF THE YEAR");

      // Date — right aligned
      auto now = id(ha_time).now();
      if (now.is_valid()) {
        char datebuf[32];
        now.strftime(datebuf, sizeof(datebuf), "%a  %b %d, %Y");
        it.print(W - 16, 12, id(font_medium), WHITE,
                 TextAlign::TOP_RIGHT, datebuf);
      }

      // Battery — below date
      float batt = id(battery_level).state;
      if (!isnan(batt)) {
        it.printf(W - 16, 35, id(font_tiny), WHITE,
                  TextAlign::TOP_RIGHT, "Battery: %.0f%%", batt);
      }

      // Season badge — centered in header subtitle area
      if (id(current_season).has_state()) {
        std::string season_str = id(current_season).state;
        // Color-code season in the header
        Color season_col = WHITE;
        if (season_str == "Spring") season_col = GREEN;
        else if (season_str == "Summer") season_col = YELLOW;
        else if (season_str == "Autumn") season_col = RED;
        else if (season_str == "Winter") season_col = BLUE;

        it.printf(400, 35, id(font_tiny), season_col,
                  TextAlign::TOP_CENTER, "%s", season_str.c_str());
      }

      // Thin accent line below header
      it.filled_rectangle(0, 52, W, 2, YELLOW);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2a — MOON PHASE  (x: 0–305, y: 56–262)
      // The moon phase is the spiritual heartbeat of the display.
      // ════════════════════════════════════════════════════════════════════════
      it.print(12, 60, id(font_medium), BLUE, "LUNAR PHASE");
      it.filled_rectangle(12, 82, 285, 1, BLUE);

      // ── Draw Moon Circle (simplified) ──────────────────────────────────
      // Center the moon disc at (80, 150), radius 42
      const int MX = 80;
      const int MY = 155;
      const int MOON_R = 42;

      // Outer circle (full disc outline)
      it.circle(MX, MY, MOON_R, BLACK);
      it.circle(MX, MY, MOON_R - 1, BLACK);

      // Fill based on phase name to approximate appearance
      // We draw a filled circle then overlay to simulate the phase
      float illum = 0.0;
      if (!isnan(id(moon_illumination).state)) {
        illum = id(moon_illumination).state;
      }

      // Full disc background (dark side)
      it.filled_circle(MX, MY, MOON_R - 2, BLACK);

      // Approximate lit portion using illumination percentage
      // For simplicity on ePaper: fill proportional vertical slices
      // from the right (waxing) or left (waning) side
      bool is_waning = false;
      if (id(moon_phase).has_state()) {
        std::string phase = id(moon_phase).state;
        is_waning = (phase.find("Waning") != std::string::npos ||
                     phase.find("Third") != std::string::npos);
      }

      int lit_width = (int)(MOON_R * 2.0 * illum / 100.0);
      if (lit_width > 0) {
        if (is_waning) {
          // Lit from left
          for (int col = 0; col < lit_width && col < MOON_R * 2; col++) {
            int x = MX - MOON_R + 2 + col;
            // Calculate vertical extent at this x using circle equation
            int dx = x - MX;
            int h = (int)sqrt((float)(MOON_R * MOON_R - dx * dx));
            if (h > 0) {
              it.line(x, MY - h + 2, x, MY + h - 2, WHITE);
            }
          }
        } else {
          // Lit from right (waxing / full)
          for (int col = 0; col < lit_width && col < MOON_R * 2; col++) {
            int x = MX + MOON_R - 2 - col;
            int dx = x - MX;
            int h = (int)sqrt((float)(MOON_R * MOON_R - dx * dx));
            if (h > 0) {
              it.line(x, MY - h + 2, x, MY + h - 2, WHITE);
            }
          }
        }
      }

      // Phase name — large, to the right of the moon disc
      if (id(moon_phase).has_state()) {
        it.print(138, 92, id(font_large), BLACK,
                 id(moon_phase).state.c_str());
      } else {
        it.print(138, 92, id(font_large), BLACK, "---");
      }

      // Illumination percentage
      if (!isnan(illum)) {
        it.printf(138, 128, id(font_body), BLACK,
                  "%.0f%% Illuminated", illum);
      }

      // Magickal correspondence
      it.print(12, 205, id(font_small), BLUE, "Magick:");
      if (id(moon_magick).has_state()) {
        // Truncate if too long for display width
        std::string magick = id(moon_magick).state;
        if (magick.length() > 48) {
          magick = magick.substr(0, 45) + "...";
        }
        it.print(12, 222, id(font_small), BLACK, magick.c_str());
      }

      // Thin border at panel bottom
      it.filled_rectangle(12, 248, 285, 1, BLACK);

      // Vertical divider
      it.filled_rectangle(310, 56, 2, 208, BLACK);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2b — NEXT SABBAT  (x: 320–520, y: 56–262)
      // Prominently shows the approaching sabbat.
      // ════════════════════════════════════════════════════════════════════════
      it.print(320, 60, id(font_medium), RED, "NEXT SABBAT");
      it.filled_rectangle(320, 82, 195, 1, RED);

      if (id(next_sabbat).has_state()) {
        // Sabbat name — large yellow
        it.print(320, 90, id(font_large), YELLOW,
                 id(next_sabbat).state.c_str());
      }

      // Alt name (e.g. "Spring Equinox")
      if (id(next_sabbat_alt).has_state()) {
        it.print(320, 124, id(font_body), BLACK,
                 id(next_sabbat_alt).state.c_str());
      }

      // Date
      if (id(next_sabbat_date).has_state()) {
        it.print(320, 146, id(font_small), BLACK,
                 id(next_sabbat_date).state.c_str());
      }

      // Days countdown — find which sabbat sensor matches
      // Use the next_sabbat name to pick the right countdown sensor
      float days_left = NAN;
      if (id(next_sabbat).has_state()) {
        std::string ns = id(next_sabbat).state;
        if (ns == "Yule")        days_left = id(sabbat_yule).state;
        else if (ns == "Imbolc") days_left = id(sabbat_imbolc).state;
        else if (ns == "Ostara") days_left = id(sabbat_ostara).state;
        else if (ns == "Beltane") days_left = id(sabbat_beltane).state;
        else if (ns == "Litha")  days_left = id(sabbat_litha).state;
        else if (ns == "Lughnasadh") days_left = id(sabbat_lughnasadh).state;
        else if (ns == "Mabon")  days_left = id(sabbat_mabon).state;
        else if (ns == "Samhain") days_left = id(sabbat_samhain).state;
      }

      if (!isnan(days_left)) {
        if (days_left < 0.5) {
          it.print(320, 168, id(font_medium), YELLOW, "TODAY!");
        } else {
          it.printf(320, 168, id(font_medium), RED,
                    "%.0f days", days_left);
        }
      }

      // Brief description (first ~60 chars)
      if (id(next_sabbat_description).has_state()) {
        std::string desc = id(next_sabbat_description).state;
        // Wrap to ~35 chars per line, 2 lines max
        if (desc.length() > 70) desc = desc.substr(0, 67) + "...";
        size_t mid = desc.find(' ', 33);
        if (mid != std::string::npos && mid < 45) {
          it.print(320, 196, id(font_tiny), BLACK,
                   desc.substr(0, mid).c_str());
          it.print(320, 210, id(font_tiny), BLACK,
                   desc.substr(mid + 1).c_str());
        } else {
          it.print(320, 196, id(font_tiny), BLACK, desc.c_str());
        }
      }

      it.filled_rectangle(320, 248, 195, 1, BLACK);

      // Vertical divider
      it.filled_rectangle(525, 56, 2, 208, BLACK);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 2c — SUN SIGN + SEASON  (x: 535–790, y: 56–262)
      // ════════════════════════════════════════════════════════════════════════
      it.print(535, 60, id(font_medium), YELLOW, "SUN SIGN");
      it.filled_rectangle(535, 82, 255, 1, YELLOW);

      // Sign name — large
      if (id(sun_sign).has_state()) {
        it.print(535, 90, id(font_large), BLACK,
                 id(sun_sign).state.c_str());
      }

      // Element + quality
      if (id(sun_sign_element).has_state()) {
        it.print(535, 126, id(font_body), GREEN,
                 id(sun_sign_element).state.c_str());
      }

      // ── Season block ──
      it.filled_rectangle(535, 152, 255, 1, BLACK);
      it.print(535, 158, id(font_medium), GREEN, "SEASON");

      if (id(current_season).has_state()) {
        Color s_col = BLACK;
        std::string sn = id(current_season).state;
        if (sn == "Spring") s_col = GREEN;
        else if (sn == "Summer") s_col = YELLOW;
        else if (sn == "Autumn") s_col = RED;
        else if (sn == "Winter") s_col = BLUE;

        it.print(535, 180, id(font_large), s_col, sn.c_str());
      }

      // Season short description
      if (id(season_description).has_state()) {
        std::string sd = id(season_description).state;
        if (sd.length() > 70) sd = sd.substr(0, 67) + "...";
        size_t mid = sd.find(' ', 33);
        if (mid != std::string::npos && mid < 45) {
          it.print(535, 216, id(font_tiny), BLACK,
                   sd.substr(0, mid).c_str());
          it.print(535, 230, id(font_tiny), BLACK,
                   sd.substr(mid + 1).c_str());
        } else {
          it.print(535, 216, id(font_tiny), BLACK, sd.c_str());
        }
      }

      it.filled_rectangle(535, 248, 255, 1, BLACK);

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 3 — PLANETARY POSITIONS  (y: 256–310)
      // Compact row showing key planet transits
      // ════════════════════════════════════════════════════════════════════════
      it.filled_rectangle(0, 256, W, 2, BLACK);
      it.filled_rectangle(0, 256, W, 24, BLACK);
      it.print(W / 2, 258, id(font_small), YELLOW,
               TextAlign::TOP_CENTER, "PLANETARY POSITIONS");
      it.filled_rectangle(0, 280, W, 1, YELLOW);

      // 7 planets across 800px ≈ 114px each
      struct PlanetDisplay {
        const char *label;
        text_sensor::TextSensor *sensor_ptr;
        Color color;
      };

      // We'll build this inline since lambda can't use initializer lists
      // of pointers easily — just do them sequentially
      const int P_Y = 286;
      const int P_COLS = 7;
      const int P_COL_W = W / P_COLS;  // ~114px

      // Planet 0: Sun
      it.print(P_COL_W * 0 + 6, P_Y, id(font_tiny), YELLOW, "Sun");
      if (id(planet_sun).has_state()) {
        it.print(P_COL_W * 0 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_sun).state.c_str());
      }

      // Planet 1: Moon
      it.print(P_COL_W * 1 + 6, P_Y, id(font_tiny), BLUE, "Moon");
      if (id(planet_moon).has_state()) {
        it.print(P_COL_W * 1 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_moon).state.c_str());
      }

      // Planet 2: Mercury
      it.print(P_COL_W * 2 + 6, P_Y, id(font_tiny), BLACK, "Mercury");
      if (id(planet_mercury).has_state()) {
        it.print(P_COL_W * 2 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_mercury).state.c_str());
      }

      // Planet 3: Venus
      it.print(P_COL_W * 3 + 6, P_Y, id(font_tiny), GREEN, "Venus");
      if (id(planet_venus).has_state()) {
        it.print(P_COL_W * 3 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_venus).state.c_str());
      }

      // Planet 4: Mars
      it.print(P_COL_W * 4 + 6, P_Y, id(font_tiny), RED, "Mars");
      if (id(planet_mars).has_state()) {
        it.print(P_COL_W * 4 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_mars).state.c_str());
      }

      // Planet 5: Jupiter
      it.print(P_COL_W * 5 + 6, P_Y, id(font_tiny), YELLOW, "Jupiter");
      if (id(planet_jupiter).has_state()) {
        it.print(P_COL_W * 5 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_jupiter).state.c_str());
      }

      // Planet 6: Saturn
      it.print(P_COL_W * 6 + 6, P_Y, id(font_tiny), BLACK, "Saturn");
      if (id(planet_saturn).has_state()) {
        it.print(P_COL_W * 6 + 6, P_Y + 13, id(font_small), BLACK,
                 id(planet_saturn).state.c_str());
      }

      // Column dividers
      for (int i = 1; i < P_COLS; i++) {
        it.filled_rectangle(P_COL_W * i, 282, 1, 30, BLACK);
      }

      // ════════════════════════════════════════════════════════════════════════
      // SECTION 4 — SABBAT COUNTDOWNS  (y: 316–478)
      // 8 sabbats in a 2×4 grid. Each cell ~200×80px.
      // Color-coded: solar sabbats (YELLOW), cross-quarter (RED)
      // The "next" sabbat gets a highlight border.
      // ════════════════════════════════════════════════════════════════════════
      const int SB_Y0 = 316;

      it.filled_rectangle(0, SB_Y0, W, 2, BLACK);
      it.filled_rectangle(0, SB_Y0, W, 22, BLACK);
      it.print(W / 2, SB_Y0 + 2, id(font_small), WHITE,
               TextAlign::TOP_CENTER, "SABBAT COUNTDOWNS");
      it.filled_rectangle(0, SB_Y0 + 22, W, 1, YELLOW);

      const int SB_TOP = SB_Y0 + 25;   // y where grid content starts
      const int CELL_W = 200;           // 800 / 4
      const int CELL_H = 76;            // (478 - 326) / 2

      // Sabbat data: name, type (solar/cross), sensor reference
      // type: 0=solar (solstice/equinox), 1=cross-quarter
      struct SabbatInfo {
        const char *name;
        const char *alt;
        int type;       // 0=solar, 1=cross
        float days;
      };

      SabbatInfo sabbats[8] = {
        {"Yule",       "Winter Solstice",  0, id(sabbat_yule).state},
        {"Imbolc",     "Brigid's Day",     1, id(sabbat_imbolc).state},
        {"Ostara",     "Spring Equinox",   0, id(sabbat_ostara).state},
        {"Beltane",    "May Day",          1, id(sabbat_beltane).state},
        {"Litha",      "Summer Solstice",  0, id(sabbat_litha).state},
        {"Lughnasadh", "Lammas",           1, id(sabbat_lughnasadh).state},
        {"Mabon",      "Autumn Equinox",   0, id(sabbat_mabon).state},
        {"Samhain",    "Hallows' Eve",     1, id(sabbat_samhain).state},
      };

      // Find which sabbat is next (smallest days > 0, or == 0)
      int next_idx = -1;
      float min_days = 999;
      for (int i = 0; i < 8; i++) {
        if (!isnan(sabbats[i].days) && sabbats[i].days >= 0 && sabbats[i].days < min_days) {
          min_days = sabbats[i].days;
          next_idx = i;
        }
      }

      for (int i = 0; i < 8; i++) {
        int col = i % 4;
        int row = i / 4;
        int x0 = col * CELL_W;
        int y0 = SB_TOP + row * CELL_H;

        // Highlight box for next sabbat
        if (i == next_idx) {
          it.filled_rectangle(x0 + 1, y0 + 1, CELL_W - 2, CELL_H - 2, YELLOW);
          // Redraw text on yellow background → use BLACK for everything
        }

        // Cell border
        it.rectangle(x0, y0, CELL_W, CELL_H, BLACK);

        // Sabbat name — color by type
        Color name_col = sabbats[i].type == 0 ? YELLOW : RED;
        if (i == next_idx) name_col = BLACK;  // on yellow bg

        it.print(x0 + 8, y0 + 4, id(font_medium), name_col,
                 sabbats[i].name);

        // Alt name
        Color alt_col = i == next_idx ? BLACK : BLACK;
        it.print(x0 + 8, y0 + 28, id(font_tiny), alt_col,
                 sabbats[i].alt);

        // Days countdown
        if (!isnan(sabbats[i].days)) {
          Color days_col = i == next_idx ? RED : BLUE;
          if (sabbats[i].days < 0.5) {
            it.print(x0 + 8, y0 + 46, id(font_medium),
                     i == next_idx ? RED : GREEN, "TODAY!");
          } else {
            it.printf(x0 + 8, y0 + 46, id(font_medium), days_col,
                      "%.0f days", sabbats[i].days);
          }
        } else {
          it.print(x0 + 8, y0 + 46, id(font_medium), BLACK, "---");
        }
      }

      // Bottom border
      it.filled_rectangle(0, H - 2, W, 2, BLACK);